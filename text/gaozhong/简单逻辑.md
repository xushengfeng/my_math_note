# 简单逻辑

逻辑将是我们使用 lean 来进行证明的基础，在日常做题时，清晰的逻辑可以帮助你进行更严谨地思考。

## 命题

命题是可以判断真假的陈述句。在 lean 中，`Prop`类型表示命题，比如`p : Prop`表示`p`是一个命题。`1 + 1 = 2`是一个命题，`1 + 1 = 3`也是一个命题（不过是假命题），`1 + 1`无法判断真假，所以不是命题。在 lean 中，`True`表示真，`False`表示假。所谓真假，就是这个命题符合某个标准，比如`1 + 1 = 2`符合数学的标准，所以是真命题。我们这里讨论的是数学，所以命题的真假是基于数学的标准。当然，一些现实生活的命题例子可以帮助理解。

## 逻辑联结词

我们平时会用到“和”这个概念，比如“我喜欢数学和物理”这个命题是真，这句话的意思是“我喜欢数学”这个命题和“我喜欢物理”这个命题都是真的。还有“且”，“都”等词也表示这样的并列关系。在逻辑中，他还有个名字叫“**合取**”（And）。合取操作可以把两个命题组合成一个命题。在 lean 中，我们用`∧`表示合取，比如`p : Prop`，`q : Prop`，`p ∧ q : Prop`。

既然合取命题是命题，那如何判断他的真假呢？我们总结现实直觉，只有当`p`和`q`这两个命题都是真的时候，`p ∧ q`才是真的，否则就是假的。

| `p`     | `q`     | `p ∧ q` |
| ------- | ------- | ------- |
| `True`  | `True`  | `True`  |
| `True`  | `False` | `False` |
| `False` | `True`  | `False` |
| `False` | `False` | `False` |

上面这样的表格，我们叫作“真值表”，可以帮助我们理解逻辑联结词的含义，或者说，有了真值表，我们不用再在脑海里思考复杂的逻辑，不需要思考合取是什么意思（现实的例子只是方便理解，数学上我们还是看表），查询这个表就可以了。我们还可以看到，合取命题`p ∧ q`是真的，可以反过来知道`p`和`q`都是真的。

类似的，还有“或”，叫“**析取**”（Or）。在 lean 中用`∨`表示，`p ∨ q`。

| `p`     | `q`     | `p ∨ q` |
| ------- | ------- | ------- |
| `True`  | `True`  | `True`  |
| `True`  | `False` | `True`  |
| `False` | `True`  | `True`  |
| `False` | `False` | `False` |

析取命题在任意一个子命题为`True`时，整体为`True`。这可能与我们的理解有些差别，他是可以“全都要”的，不止“二选一”。

**否定**（Not），非，在 lean 中表示为`¬`，与上面两个不同，他只针对一个命题，命题`p`为`True`时，`¬p`为`False`；命题`p`为`False`时，`¬p`为`True`。

**蕴含**（Imp），符号为`→`。真值表如下：

| `p`     | `q`     | `p → q` |
| ------- | ------- | ------- |
| `True`  | `True`  | `True`  |
| `True`  | `False` | `False` |
| `False` | `True`  | `True`  |
| `False` | `False` | `True`  |

看到这个符号的样子，还有你也许听过蕴含有“如果……那么……”的意思。这仿佛在说`p`和`q`之间存在某些关系。但是在逻辑中，他们的关系只有真值表所显示的那样，也就是说“如果太阳从东边升起，那么 1+1=2”是逻辑的，但这样的表达让人摸不着头脑。所以，要把蕴含当成一个逻辑联结词，像合取、析取一样，不要去想他在现实生活中是什么意思，也不要管他的中文意思。

**等价**（Iff），符号为`↔`。真值表如下：

| `p`     | `q`     | `p ↔ q` |
| ------- | ------- | ------- |
| `True`  | `True`  | `True`  |
| `True`  | `False` | `False` |
| `False` | `True`  | `False` |
| `False` | `False` | `True`  |

等价命题`p ↔ q`是真的，意味着`p`和`q`的真假相同，反过来也一样。也就是说，`p`和`q`要么都是真的，要么都是假的。

就像加法一样，`+`是求两个数的和，如果我们要求三个数的和，我们可以写`a + b + c`，这其实是`(a + b) + c`的简写。逻辑联结词也是一样的，`p ∧ q ∧ r`其实是`(p ∧ q) ∧ r`的简写。先判断`p ∧ q`的真假，然后再和`r`进行合取。这五个基本的逻辑联结词，我们可以按需组合，形成更复杂的命题。类似的，他们直接也有优先级，`¬`最高，然后是`∧`，然后是`∨`，然后是`→`，最后是`↔`。有括号先算括号，同级的*从右往左*，所以，`¬p ∨ q ∧ r → s ↔ t`其实是`((¬p) ∨ (q ∧ r)) → s ↔ t`的简写。

## 量词

因为变量的存在，像`x > 0`这样的东西并不是一个命题，或者说是存在歧义的，我们无法判断真假。我们往往需要明确变量`x`，比如给定具体的值`x = 1`。或者给定一个范围`x ∈ R`，但是这又回到开始的定义不准确了。有范围，最终还是要代入具体的值，那应该选择那些值呢？我们常用的有两种选择方式：全部和一个。全部，说的是“所有的”“任意”“每一个”，这些词叫“全称量词”，包含这些的命题叫“全称量词命题”。全称量词命题用 `∀ x : α, p x` 表示，对于每一个 `x : α, p x` 成立，`p x`是任意含有`x`的句子。一个，说的是“存在一个”“至少有一个”“有些”“有的”“有一个”，这些词叫“存在量词”，命题是“存在量词命题”，`∃ x : α, p x`。这些量词的功能，可以类比为，`∀`像`∧`，`∃`像`∨`，当然，变量`x`的取值的情况可能是无限的，用量词表达更方便。

这些量词命题，都是进行若干次选择（取出）某个值代入到`x`，去判断代入后的命题（不管前面的量词）是否成立，然后在全局看看成立的结果来判断整个量词命题成不成立。全称量词命题，就是所有取出的值都成立，整体才成立，只要有一个值让小命题不成立，那么整个命题就不成立。存在量词命题，是只要有一个取出的值成立，就成立，如果全都不成立（一个也没有），那整体不成立。

全称量词命题：

| 小命题成立情况       | 整体成立情况 |
| -------------------- | ------------ |
| 全部成立             | 整体成立     |
| 一个（或以上）不成立 | 整体不成立   |

存在量词命题：

| 小命题成立情况     | 整体成立情况 |
| ------------------ | ------------ |
| 一个（或以上）成立 | 整体成立     |
| 全都不成立         | 整体不成立   |

从上面的类似真值表的表格中，我们可以看到我们说的全称和存在是针对成立情况的，不成立情况他们反过来。

`∀ x : α, p x`等价于`¬(∃ x : α, ¬(p x))`，`∃ x : α, p x`等价于`¬(∀ x : α, ¬(p x))`。你可以在后面的例题中找到合取析取类似的形式。

在一些教材中把范围写在前面。`p x`为限制条件，比如`∀ x : 类型, x的范围 → p x`，lean 也支持简写为教材那样`∀ x的范围, p x`。而`∃ x : 类型, x的范围 ∧ p x`简写为`∃ x的范围, p x`。还有一些教材先用集合（先不管这是什么）表示范围。简写后，你可以理解为`x`的查找范围变了，那为什么他们的扩写不一样？你可以像上面一样类比合取析取，然后用下面提到的相关公式或者真值表来计算。下面我简单用大白话建立一种理解。扩写下，当`x`取到某个值时，在范围内时，无论是`→`还是`∧`，整个这次的取出成立与否与`p x`一致，简写就`p x`这个写出来的条件，所以与简写是一个意思。关键是`x`不在范围的行为，对照真值表，我们发现前面的条件为`Flase`时，不管`p x`如何，合取结果都是`False`，蕴含结果都是`True`，也就是不再范围的结果被统一设定了。`x`不在范围，我们都希望其不影响`x`在范围内的判断。全称扩写时定为`True`，对照上面的全称量词命题表格发现，即不影响范围内都成立，也不影响范围内存在不成立的情况，如果不在范围定为`False`，那命题永远都是不成立的。类似的可以对照存在量词命题。

## 证明

证明就是告诉别人某个命题是真的。我们可以通过逻辑联结词的真值表来进行证明。比如，我们要证明`p ∧ q`是真的，我们可以证明`p`是真的，`q`也是真的。因为根据合取的真值表，只有当`p`和`q`都是真的时候，`p ∧ q`才是真的。

我们还有一些命题，会用到“推出”这种说法，符号为 $\to$ ，但在 lean 中，一般我们表示为`⊢`，他是蕴含的加强版，要求推理成立。

在 lean 里面，条件用括号分别包裹，结论跟在`:`后面，比如`example (p q : Prop) (h : p ∨ q) : q ∨ p := by`。`:= by`后面换行空格写具体证明过程。而多个条件，实际上是合取关系，比如有条件`(h1 : Prop) (h2 : Prop) (h3 : Prop)`，他们其实是`(h : h1 ∧ h2 ∧ h3)`。

考虑命题：`h ⊢ r`，由于推理过程是后面才完成的，所以推理前我们可以把他看成是蕴含命题 todo 真的可以这样想吗`h → r`，如果条件`h`为假，`h → r`为真（即爆炸律，在 lean 中，用`contradicion`说明结束）。所以，证明时，我们一般默认条件都是真的（即每个条件都是真的），这样我们只需要证明目标是`True`，那整个命题就是`True`。

一个逻辑命题作为条件，和作为结论是有区别的。上面我们提到的逻辑命题，都是作为结论的。下面我们举几个例子：

合取命题`h1 ∧ h2`作为结论，需要知道（证明）`h1`，也要证明`h2`。这里会有一个分类的过程。在 lean 中，我们用`apply And.intro`来表示分类，表示我们要把目标`h1 ∧ h2`分成两种情况，左边（left）是目标为`h1`的小命题，右边（right）是目标为`h2`的。

合取命题作为前提，比如`(h : h1 ∧ h2)`，那`h`就是`True`，我们回去找真值表的右边，可以看到只有一种情况，`h1`和`h2`都是真的时候，`h1 ∧ h2`才是真的，所以我们可以知道`h1`是真的，`h2`也是真的。后面要使用他们作为前提，`h1`，`h2`只是我们的演示，实际上他们可以是很长的句子，所以我们这里用`h.left`来拿到`h1`或`h.right`拿到`h2`。

析取命题`h1 ∨ h2`作为结论，要使其成立（为`True`）只需要`h1`、`h2`直接有一个成立就可以了。`apply Or.inl`或者`left`可以选择左边的命题去证明，或者`apply Or.inr`或者`right`选择左边的。

析取命题`(h : h1 ∨ h2)`作为前提，要使这个`h`命题为`True`，根据真值表，我们可以发现有 3 种情况：1：`h1`为`True`，`h2`为`False`；2：`h1`为`False`，`h2`为`True`；3：`h1`为`True`，`h2`为`True`。我们要做的是，把`h`这个前提拆开来用，但是如果我们只用前提`h1`，在情况 2 中可能为`Flase`，这样前提就不为真了，可能给我们的证明造成极大麻烦。所以以上三种情况我们都要考虑。使用`rcases h with a | b`可以把`h`分类为情况 a 和 b，a：`h1`为`True`，`h2`可以是`True`或`False`，但我们现在有了`h1`，就可以用`h1`去证明。b：`h1`可以是`True`或`False`，`h2`为`True`。可以看到，情况 ab 和上面的 123 分类是一样的，只不过把情况 3 分开来。对于这些情况，我们不知道具体是那个（实际上是每种情况都适用），但分类后，我们各自证明了这些情况，那不管是什么情况都有一个证明，所以整体证明就完成了。

我们看到，他们作为结论，使用是符合我们直觉的，但是，他们作为前提，就要反过来考虑真值表，合取前提像析取一样只要一个就行了，析取前提像合取一样要分类讨论。

上面的操作，叫消去规则和引入规则，我们都写出定义（注意，并不是正确的 lean 语法格式，仅示意）。

合取消去：`(h1 ∧ h2) ⊢ h1`或`(h1 ∧ h2) ⊢ h2`

合取引入：`(h1) (h2) ⊢ (h1 ∧ h2)`

析取消去：`(h1 ∨ h2) (h1 → p) (h2 → p) ⊢ p`

析取引入：`(h1) ⊢ (h1 ∨ h2)`或`(h2) ⊢ (h1 ∨ h2)`

蕴含消去：`(h1 → h2) (h1) ⊢ h2`

蕴含引入：`(h) (h1) ⊢ h2` 推出 `(h) ⊢ h1 → h2`

等价消去：`(h1 ↔ h2) (h1) ⊢ h2`或`(h1 ↔ h2) (h2) ⊢ h1`

等价引入：`(h1 → h2) (h2 → h1) ⊢ (h1 ↔ h2)`

我们先不管否定。

以下是证明：

[](p:0123adf?showAnswer)
